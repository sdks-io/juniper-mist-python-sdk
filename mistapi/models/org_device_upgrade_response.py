# -*- coding: utf-8 -*-

"""
mistapi

This file was automatically generated by APIMATIC v3.0 (
 https://www.apimatic.io ).
"""
from mistapi.api_helper import APIHelper
from mistapi.models.upgrade import Upgrade


class OrgDeviceUpgradeResponse(object):

    """Implementation of the 'org_device_upgrade_response' model.

    TODO: type model description here.

    Attributes:
        enable_p_2_p (bool): whether to allow local AP-to-AP FW upgrade
        force (bool): whether to force upgrade when requested version is same
            as running version
        id (uuid|string): unique id for the upgrade
        start_time (float): upgrade start time in epoch
        status (Status1Enum): status upgrade is in
        strategy (Strategy1Enum): upgrade strategy
        target_version (string): version to upgrade to
        upgrades (list of Upgrade): TODO: type description here.

    """

    # Create a mapping from Model property names to API property names
    _names = {
        "id": 'id',
        "enable_p_2_p": 'enable_p2p',
        "force": 'force',
        "start_time": 'start_time',
        "status": 'status',
        "strategy": 'strategy',
        "target_version": 'target_version',
        "upgrades": 'upgrades'
    }

    _optionals = [
        'enable_p_2_p',
        'force',
        'start_time',
        'status',
        'strategy',
        'target_version',
        'upgrades',
    ]

    def __init__(self,
                 id=None,
                 enable_p_2_p=APIHelper.SKIP,
                 force=APIHelper.SKIP,
                 start_time=APIHelper.SKIP,
                 status=APIHelper.SKIP,
                 strategy='big_bang',
                 target_version=APIHelper.SKIP,
                 upgrades=APIHelper.SKIP):
        """Constructor for the OrgDeviceUpgradeResponse class"""

        # Initialize members of the class
        if enable_p_2_p is not APIHelper.SKIP:
            self.enable_p_2_p = enable_p_2_p 
        if force is not APIHelper.SKIP:
            self.force = force 
        self.id = id 
        if start_time is not APIHelper.SKIP:
            self.start_time = start_time 
        if status is not APIHelper.SKIP:
            self.status = status 
        self.strategy = strategy 
        if target_version is not APIHelper.SKIP:
            self.target_version = target_version 
        if upgrades is not APIHelper.SKIP:
            self.upgrades = upgrades 

    @classmethod
    def from_dictionary(cls,
                        dictionary):
        """Creates an instance of this model from a dictionary

        Args:
            dictionary (dictionary): A dictionary representation of the object
            as obtained from the deserialization of the server's response. The
            keys MUST match property names in the API description.

        Returns:
            object: An instance of this structure class.

        """
        if dictionary is None:
            return None

        # Extract variables from the dictionary

        id = dictionary.get("id") if dictionary.get("id") else None
        enable_p_2_p = dictionary.get("enable_p2p") if "enable_p2p" in dictionary.keys() else APIHelper.SKIP
        force = dictionary.get("force") if "force" in dictionary.keys() else APIHelper.SKIP
        start_time = dictionary.get("start_time") if dictionary.get("start_time") else APIHelper.SKIP
        status = dictionary.get("status") if dictionary.get("status") else APIHelper.SKIP
        strategy = dictionary.get("strategy") if dictionary.get("strategy") else 'big_bang'
        target_version = dictionary.get("target_version") if dictionary.get("target_version") else APIHelper.SKIP
        upgrades = None
        if dictionary.get('upgrades') is not None:
            upgrades = [Upgrade.from_dictionary(x) for x in dictionary.get('upgrades')]
        else:
            upgrades = APIHelper.SKIP
        # Return an object of this model
        return cls(id,
                   enable_p_2_p,
                   force,
                   start_time,
                   status,
                   strategy,
                   target_version,
                   upgrades)
